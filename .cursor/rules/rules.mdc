# 프로젝트 공통 규칙

## 1. 커밋 & 브랜치 정책
- 설정 파일 작업: 브랜치 `chore/설정파일명-간단설명`, 커밋 `chore: ...`
- 문서 작업: 브랜치 `docs/문서명-간단설명`, 커밋 `docs: ...`
- 신규 기능: 브랜치 `feat/기능명-간단설명`, 커밋 `feat: ...`
- 기능 수정/버그: 브랜치 `fix/수정내용-간단설명`, 커밋 `fix: ...`

## 2. 이슈 & PR 템플릿
- 이슈 생성 시 `.github/ISSUE_TEMPLATE` 내 템플릿을 목적에 맞게 선택합니다.
- Pull Request는 `.github/PULL_REQUEST_TEMPLATE/pull-request.md` 양식에 따라 작성합니다.
- 체크리스트는 실제 진행 상황에 맞춰 업데이트합니다.

## 3. 프로젝트 구조 유지
- `.cursor/` 내부 구성: `project-plan.md`, `rules/rules.mdc`, `commands/commands.yaml` 필수 유지
- `.github/ISSUE_TEMPLATE/`와 `.github/PULL_REQUEST_TEMPLATE/` 디렉터리는 삭제하거나 이동하지 않습니다.
- 신규 규칙이나 절차가 생기면 `rules.mdc`를 업데이트해 공유합니다.

## 4. 네이밍 규칙
### 4.1 라우터 (Routes) - 엔드포인트 핸들러
- **형식**: `{HTTP메서드}_{동사}_{리소스명}` (snake_case)
- **목적**: HTTP 메서드와 기능을 명확히 표현하고, 서비스 함수와 이름 충돌 방지
- **예시**:
  ```python
  def post_process_video_url(...)      # POST /api/video - URL 처리
  def post_get_video_transcript(...)   # POST /api/video/{video_id}/transcript - 자막 가져오기
  def get_list_videos(...)             # GET /api/videos - 목록 조회
  def get_detail_video(...)            # GET /api/videos/{video_id} - 상세 조회
  def post_create_video(...)           # POST /api/videos - 생성
  def put_update_video(...)            # PUT /api/videos/{video_id} - 수정
  def delete_remove_video(...)         # DELETE /api/videos/{video_id} - 삭제
  ```

### 4.2 서비스 (Services) - 비즈니스 로직
- **형식**: `{동사}_{명사}` (snake_case)
- **목적**: 기능을 명확히 표현하는 동사 + 처리할 리소스명
- **예시**:
  ```python
  def extract_video_id(...)    # Video ID 추출
  def get_transcript(...)       # 자막 가져오기
  def validate_url(...)         # URL 검증
  def process_transcript(...)   # 자막 처리
  ```

### 4.3 스키마 (Schemas) - Pydantic Models
- **형식**: `{도메인}{용도}` (PascalCase)
- **Request 스키마**: `{도메인}Request` (단수형 권장)
- **Response 스키마**: `{도메인}Response`
- **예시**:
  ```python
  VideoUrlRequest      # Request (단수형)
  VideoUrlResponse     # Response
  TranscriptResponse   # Response
  VocabularyRequest    # 향후 필요시
  VocabularyResponse   # 향후 필요시
  ```

### 4.4 네이밍 충돌 방지
- 라우터 함수는 반드시 `{HTTP메서드}_` 접두사를 사용하여 서비스 함수와 구분
- 서비스 함수는 동사로 시작하여 기능을 명확히 표현
- 스키마는 PascalCase를 사용하여 함수와 구분

## 5. 개발 진행 원칙
- 기능 구현 → 에러 핸들링 → 수동 테스트 → 자동 테스트 순으로 진행합니다.
- 각 작업 단계에서 명령어와 파일의 역할을 명확히 설명하고 문서화합니다.
- 테스트 코드는 AAA(Arrange-Act-Assert) 패턴을 따르며 필요 시 실행 방법을 함께 기록합니다.
- Agent는 사용자가 원하는 코드를 직접 파일에 작성하지 않고, 필요한 코드와 명령을 단계별로 안내하여 사용자가 손코딩하며 로직을 이해하도록 돕습니다.
- 각 Phase 진행 시 테스트 코드는 해당 Phase의 마지막 단계에서 전체 기능을 검증하는 수준으로 작성합니다.
- 모든 답변은 사용자의 피드백과 추가 요청을 받을 수 있도록 열린 대화 형식을 유지합니다.
- 외부 패키지를 학습할 때마다 `docs/` 이하에 패키지별 학습 내용을 정리한 `.md` 파일을 생성·갱신합니다.
- 스터디 문서(`docs/*.md`), `README.md`, `CONTRIBUTING.md`, `.cursor/project-plan.md` 등 프로젝트 문서 파일은 Agent가 직접 수정해도 됩니다.

## 6. 계획 및 문서 동기화
- 작업 단계 변경 시 `.cursor/project-plan.md`를 갱신하고 `AI Session Summary`에 기록합니다.
- Phase 완료 후 README에 영향 있는 변경이 있다면 `update_readme` 절차를 참고해 수정합니다.
- 프로젝트 진행 상황을 공유할 때는 `cursor/` 문서와 `project-plan.md`를 우선 참고합니다.

## 7. 마크다운 문서 작성 규칙
### 7.1 헤더 및 목차 링크 규칙
- **헤더 레벨 일관성**: 모든 메인 섹션은 `##` 레벨을 사용합니다. 하위 섹션은 `###`, `####` 순서로 사용합니다.
- **헤더 ID 생성 규칙**:
  - GitHub Markdown은 헤더 텍스트를 기반으로 자동으로 앵커 ID를 생성합니다.
  - 헤더에 **번호가 포함**되어 있으면 (`## 8. 테스트 디버깅 가이드`), ID 생성 시 번호도 포함됩니다 (`8-테스트-디버깅-가이드`).
  - 헤더에 **이모지가 포함**되어 있으면 (`## 📋 목차`), 링크에도 이모지를 포함해야 합니다 (`#📋-목차`).
  - 헤더에 **번호와 이모지가 모두 없으면**, 텍스트만 사용합니다 (`#테스트-폴더-구조`).
- **목차 링크 작성 방법**:
  ```markdown
  ## 📋 목차
  
  1. [테스트 폴더 구조](#📁-테스트-폴더-구조)  # 이모지 포함 헤더
  2. [테스트 종류 및 파일 분류](#🧪-테스트-종류-및-파일-분류)  # 이모지 포함 헤더
  8. [테스트 디버깅 가이드](#8-테스트-디버깅-가이드)  # 번호 포함 헤더
  9. [테스트 작성 시 주의사항](#9-테스트-작성-시-주의사항)  # 번호 포함 헤더
  ```
- **목차로 돌아가기 링크**: 각 섹션 끝에 `[↑ 목차로 돌아가기](#📋-목차)` 형식으로 추가합니다.
- **주의사항**:
  - 헤더에 명시적 ID(`{#id}`)를 추가하지 않습니다. GitHub의 자동 생성 ID를 사용합니다.
  - 목차 링크는 실제 헤더의 자동 생성 ID와 정확히 일치해야 합니다.
  - 헤더에 번호가 있으면 링크에도 번호를 포함해야 합니다.
  - 헤더에 이모지가 있으면 링크에도 이모지를 포함해야 합니다.

### 7.2 마크다운 문서 구조
- 모든 주요 문서는 목차를 포함합니다.
- 목차는 문서 상단에 배치하고, 각 섹션 끝에 목차로 돌아가기 링크를 추가합니다.
- 섹션 간 일관된 레벨 구조를 유지합니다.

> 위 규칙은 모든 협업자가 동일한 맥락에서 프로젝트를 진행하기 위한 가이드입니다.

